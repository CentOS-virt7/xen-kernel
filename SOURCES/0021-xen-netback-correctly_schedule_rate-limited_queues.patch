From a242d4a74cc4ec46c5e3d43dd07eb146be4ca233 Mon Sep 17 00:00:00 2001
From: Wei Liu <wei.liu2@xxxxxxxxxx>
Date: Tue, 20 Jun 2017 11:49:28 +0100
Subject: [PATCH] xen-netback: correctly schedule rate-limited queues

Add a flag to indicate if a queue is rate-limited. Test the flag in
NAPI poll handler and avoid rescheduling the queue if true, otherwise
we risk locking up the host. The rescheduling shall be done when
replenishing credit.

Reported-by: Jean-Louis Dupond <jean-louis@xxxxxxxxx>
Signed-off-by: Wei Liu <wei.liu2@xxxxxxxxxx>
---
 drivers/net/xen-netback/common.h    | 1 +
 drivers/net/xen-netback/interface.c | 6 +++++-
 drivers/net/xen-netback/netback.c   | 6 +++++-
 3 files changed, 11 insertions(+), 2 deletions(-)

--- linux-3.18.44/drivers/net/xen-netback/common.h	2016-10-22 22:45:02.000000000 +0200
+++ linux-3.18.44.new/drivers/net/xen-netback/common.h	2017-06-20 14:23:07.489713158 +0200
@@ -195,6 +195,7 @@
 	unsigned long   remaining_credit;
 	struct timer_list credit_timeout;
 	u64 credit_window_start;
+	bool rate_limited;
 
 	/* Statistics */
 	struct xenvif_stats stats;
diff -Naur linux-3.18.44/drivers/net/xen-netback/interface.c linux-3.18.44.new/drivers/net/xen-netback/interface.c
--- linux-3.18.44/drivers/net/xen-netback/interface.c	2016-10-22 22:45:02.000000000 +0200
+++ linux-3.18.44.new/drivers/net/xen-netback/interface.c	2017-06-20 14:24:30.034474703 +0200
@@ -99,7 +99,11 @@
 
 	if (work_done < budget) {
 		napi_complete(napi);
-		xenvif_napi_schedule_or_enable_events(queue);
+		/* If the queue is rate-limited, it shall be
+		 * rescheduled in the timer callback.
+		 */
+		if (likely(!queue->rate_limited))
+			xenvif_napi_schedule_or_enable_events(queue);
 	}
 
 	return work_done;
diff -Naur linux-3.18.44/drivers/net/xen-netback/netback.c linux-3.18.44.new/drivers/net/xen-netback/netback.c
--- linux-3.18.44/drivers/net/xen-netback/netback.c	2016-10-22 22:45:02.000000000 +0200
+++ linux-3.18.44.new/drivers/net/xen-netback/netback.c	2017-06-20 14:26:31.220061954 +0200
@@ -819,6 +819,7 @@
 		max_credit = ULONG_MAX; /* wrapped: clamp to ULONG_MAX */
 
 	queue->remaining_credit = min(max_credit, max_burst);
+	queue->rate_limited = false;
 }
 
 static void tx_credit_callback(unsigned long data)
@@ -1336,8 +1337,10 @@
 		msecs_to_jiffies(queue->credit_usec / 1000);
 
 	/* Timer could already be pending in rare cases. */
-	if (timer_pending(&queue->credit_timeout))
+	if (timer_pending(&queue->credit_timeout)) {
+		queue->rate_limited = true;
 		return true;
+	}
 
 	/* Passed the point where we can replenish credit? */
 	if (time_after_eq64(now, next_credit)) {
@@ -1354,6 +1357,7 @@
 		mod_timer(&queue->credit_timeout,
 			  next_credit);
 		queue->credit_window_start = next_credit;
+		queue->rate_limited = true;
 
 		return true;
 	}
